#include "pch.h"
#include "医疗兵Component.h"
#include "../Entity.h"
#include "../EntitySystem.h"
#include "../Space.h"
#include "../CoRoutine/CoTimer.h"
#include "../AiCo.h"
#include "走Component.h"
#include "采集Component.h"
#include "AttackComponent.h"
#include "BuildingComponent.h"
#include "找目标走过去Component.h"
#include "DefenceComponent.h"


医疗兵Component::医疗兵Component(Entity& refEntity) :m_refEntity(refEntity)
{
	m_refEntity.m_up找目标走过去->Co顶层(
		[this]()->bool {return this->可以治疗(); },
		[this]()->WpEntity {return Get最近的可治疗友方单位(); },
		[this](const Entity& refTarget, WpEntity wpEntity, 找目标走过去Component& ref找目标走过去)->CoTask<std::tuple<bool, bool>> {return Co治疗(refTarget, wpEntity, ref找目标走过去); },
		[this](WpEntity& wpEntity, bool ref仇恨目标)->void {}
	).RunNew();
}

void 医疗兵Component::AddComponent(Entity& refEntity)
{
	CHECK_VOID(!refEntity.m_up医疗兵);
	refEntity.m_up医疗兵.reset(new 医疗兵Component(refEntity));
}


bool 医疗兵Component::可以治疗()
{
	//if (m_refEntity.m_spBuilding && !m_refEntity.m_spBuilding->已造好())
	//	return false;

	if (m_refEntity.IsDead())
		return false;

	//if (造建筑Component::正在建造(m_refEntity))
	//	return false;

	if (m_refEntity.m_sp走)
	{
		if (!m_refEntity.m_sp走->m_coWalk手动控制.Finished() ||
			!m_refEntity.m_sp走->m_coWalk进地堡.Finished())
			return false;//表示不允许打断
	}
	return true;
}


CoTask<std::tuple<bool, bool>> 医疗兵Component::Co治疗(const Entity& refTarget, WpEntity wpEntity, 找目标走过去Component& ref找目标走过去)
{
	if (!m_refEntity.DistanceLessEqual(refTarget, ref找目标走过去.攻击距离(refTarget)) || !ref找目标走过去.检查穿墙(refTarget))
		co_return{ false, false };

	走Component::Cancel所有包含走路的协程(m_refEntity); //TryCancel();

	if (co_await Co治疗目标(wpEntity, m_cancel治疗))
		co_return{ true, false };

	co_return{ false, true };
}

WpEntity 医疗兵Component::Get最近的可治疗友方单位()
{
	return m_refEntity.Get最近的Entity支持地堡中的单位(Entity::友方, [this](const Entity& ref)->bool
		{
			if (!ref.m_spDefence)
				return false;
			
			if(ref.m_spDefence->已满血())
                return false;

			return true;
		});
}


void 医疗兵Component::TryCancel()
{
	if (m_cancel治疗)
	{
		//LOG(INFO) << "调用m_cancel";
		m_cancel治疗();
	}
}

#define CHECK_终止治疗目标流程 \
		if (m_refEntity.IsDead())\
			co_return false;\
		if (wp目标.expired())\
			break;\
		if (wp目标.lock()->IsDead())\
			break;\

CoTaskBool 医疗兵Component::Co治疗目标(WpEntity wp目标, FunCancel& cancel)
{
	KeepCancel kc(cancel);
	//活动单位临时阻挡 _(m_refEntity);
	EntitySystem::恢复休闲动作 _(m_refEntity, {});

	do
	{
		CHECK_终止治疗目标流程;

		m_refEntity.m_eulerAnglesY = CalculateAngle(m_refEntity.Pos(), wp目标.lock()->Pos());
		m_refEntity.BroadcastNotifyPos();
		找目标走过去Component::播放前摇动作(m_refEntity);

		CHECK_CO_RET_FALSE(m_refEntity.m_up找目标走过去);
		using namespace std;
		if (0s < m_refEntity.m_up找目标走过去->m_战斗配置.dura开始播放攻击动作 && co_await CoTimer::Wait(m_refEntity.m_up找目标走过去->m_战斗配置.dura开始播放攻击动作, cancel))
			co_return true;//协程取消

		CHECK_终止治疗目标流程;

		找目标走过去Component::播放攻击动作(m_refEntity);
		const auto u16开始伤害 = EntitySystem::升级后攻击前摇_伤害耗时(m_refEntity);
		if (0 < u16开始伤害 && co_await CoTimer::Wait(std::chrono::milliseconds(u16开始伤害), cancel))
			co_return true;//协程取消

		CHECK_终止治疗目标流程;

		auto& refDefencer = *wp目标.lock();
		CHECK_CO_RET_FALSE(m_refEntity.m_up找目标走过去);
		if (!m_refEntity.DistanceLessEqual(refDefencer, m_refEntity.m_up找目标走过去->攻击距离(refDefencer)))
			break;//要执行后摇

		if (!refDefencer.m_spDefence)
			break;//目标打不了

		找目标走过去Component::播放攻击音效(m_refEntity);

		const uint16_t u16升级后的攻击 = EntitySystem::升级后攻击(m_refEntity);
		if (0 < u16升级后的攻击)
			refDefencer.m_spDefence->受伤(u16升级后的攻击, m_refEntity.Id);

	} while (false);

	CHECK_CO_RET_FALSE(m_refEntity.m_up找目标走过去);
	if (co_await CoTimer::Wait(m_refEntity.m_up找目标走过去->m_战斗配置.dura后摇, cancel))//后摇
		co_return true;//协程取消

	if (!m_refEntity.IsDead())
	{
		EntitySystem::BroadcastChangeSkeleAnimIdle(m_refEntity);//播放休闲待机动作
	}

	co_return false;//协程正常退出
}