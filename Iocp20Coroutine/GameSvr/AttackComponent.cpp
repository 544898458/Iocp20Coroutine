#include "pch.h"
#include "AttackComponent.h"
#include "Entity.h"
#include "EntitySystem.h"
#include "PlayerComponent.h"
#include "MonsterComponent.h"
#include "../IocpNetwork/StrConv.h"
#include "GameSvrSession.h"
#include "AiCo.h"
#include "Space.h"
#include "PlayerGateSession_Game.h"
#include "采集Component.h"
#include "走Component.h"
#include "造建筑Component.h"
#include "../CoRoutine/CoTimer.h"
#include "DefenceComponent.h"
#include "BuildingComponent.h"
#include "单位.h"

extern std::unordered_map<int, uint64_t> m_mapEntityId;
void AttackComponent::AddComponent(Entity& refEntity, const 活动单位类型 类型, const float f攻击距离, const float f伤害, const float f警戒距离)
{
	CHECK_VOID(!refEntity.m_spAttack);
	refEntity.m_spAttack = std::make_shared<AttackComponent, Entity&, const 活动单位类型>(refEntity, std::forward<const 活动单位类型&&>(类型));
	refEntity.m_spAttack->m_f攻击距离 = f攻击距离;
	refEntity.m_spAttack->m_f警戒距离 = f警戒距离;
	refEntity.m_spAttack->m_f伤害 = f伤害;
	//float arrF[] = { refEntity.Pos().x,0,refEntity.Pos().z};
	//int CrowToolAddAgent(float arrF[]);
	//refEntity.m_spAttack->m_idxCrowdAgent = CrowToolAddAgent(arrF);
	//m_mapEntityId[refEntity.m_spAttack->m_idxCrowdAgent] = refEntity.Id;
	refEntity.m_spAttack->Co顶层().RunNew();
}

float AttackComponent::攻击距离(const Entity& refTarget) const
{
	const float f目标建筑半边长 = BuildingComponent::建筑半边长(refTarget);

	if (m_refEntity.m_wpOwner.expired())
		return m_f攻击距离 + f目标建筑半边长;//普通战斗单位

	auto spOwner = m_refEntity.m_wpOwner.lock();
	return m_f攻击距离 + f目标建筑半边长 + BuildingComponent::建筑半边长(*spOwner);
}

Position 怪物闲逛(const Position& refOld)
{
	auto posTarget = refOld;
	posTarget.x += std::rand() % 11 - 5;//随机走
	posTarget.z += std::rand() % 11 - 5;
	return posTarget;
}

AttackComponent::AttackComponent(Entity& refEntity, const 活动单位类型 类型) :
	m_refEntity(refEntity),
	m_类型(类型),
	m_fun空闲走向此处(怪物闲逛)
{
}

void AttackComponent::TryCancel(const bool bDestroy)
{
	if (m_cancelAttack)
	{
		//LOG(INFO) << "调用m_cancel";
		m_cancelAttack();
	}

	m_TaskCancel.TryCancel();

	if (bDestroy && m_funCancel顶层)
		m_funCancel顶层();
}

CoTaskBool AttackComponent::Co顶层()
{
	using namespace std;
	//while (!co_await CoTimer::Wait(1000ms, m_funCancel顶层))
	while (!co_await CoTimer::WaitNextUpdate(m_funCancel顶层))
	{
		if (m_refEntity.IsDead())
			co_return false;


		if (m_b搜索新的目标 && co_await Co走向警戒范围内的目标然后攻击(m_TaskCancel.cancel))
			continue;

		if (!m_refEntity.m_spPlayer && !走Component::正在走(m_refEntity))//怪随机走
		{
			走Component::Cancel所有包含走路的协程(m_refEntity); //TryCancel();

			auto posTarget = m_fun空闲走向此处(m_refEntity.Pos());
			m_refEntity.m_refSpace.CrowdToolFindNerestPos(posTarget);
			走Component::WalkToPos(m_refEntity, posTarget);
			continue;
		}
	}
	co_return true;
}

void AttackComponent::Update()
{
}

bool AttackComponent::可以攻击()
{
	if (m_refEntity.m_sp走 && !m_refEntity.m_sp走->m_coWalk手动控制.Finished())
		return false;//表示不允许打断

	if (m_refEntity.IsDead())
		return false;

	if (造建筑Component::正在建造(m_refEntity))
		return false;

	if (m_refEntity.m_sp走)
	{
		if (!m_refEntity.m_sp走->m_coWalk手动控制.Finished() ||
			!m_refEntity.m_sp走->m_coWalk进地堡.Finished())
			return false;//表示不允许打断
	}
	return true;
}

CoTaskBool AttackComponent::Co走向警戒范围内的目标然后攻击(FunCancel& funCancel)
{
	KeepCancel kc(funCancel);
	while (true)
	{
		if (!可以攻击())
			co_return false;

		const auto wpEntity = m_refEntity.m_refSpace.Get最近的Entity支持地堡中的单位(m_refEntity, true, [](const Entity& ref)->bool {return nullptr != ref.m_spDefence; });
		if (wpEntity.expired())
		{
			m_b搜索新的目标 = false;//警戒范围内没有目标
			co_return false;
		}

		Entity& refTarget = *wpEntity.lock();

		if (m_refEntity.DistanceLessEqual(refTarget, 攻击距离(refTarget)))
		{
			走Component::Cancel所有包含走路的协程(m_refEntity); //TryCancel();

			if (co_await CoAttack(wpEntity, m_cancelAttack))
				co_return true;

			continue;
		}
		else if (m_refEntity.m_wpOwner.expired() && m_refEntity.DistanceLessEqual(refTarget, m_refEntity.警戒距离()) &&
			//!走Component::正在走(m_refEntity) && 
			(!m_refEntity.m_sp采集 || m_refEntity.m_sp采集->m_TaskCancel.co.Finished()))
		{
			走Component::Cancel所有包含走路的协程(m_refEntity); //TryCancel();

			if (m_refEntity.m_sp采集)
			{
				m_refEntity.m_sp采集->m_TaskCancel.TryCancel();
			}

			if (co_await AiCo::WalkToTarget(m_refEntity, wpEntity.lock(), funCancel))
				co_return true;

			continue;
		}

		co_return false;
	}

	co_return false;
}


CoTaskBool AttackComponent::CoAttack(WpEntity wpDefencer, FunCancel& cancel)
{
	KeepCancel kc(cancel);

	if (m_refEntity.IsDead())
		co_return false;//自己死亡

	m_refEntity.BroadcastChangeSkeleAnim("attack");//播放攻击动作

	using namespace std;

	const std::tuple<std::chrono::milliseconds, int> arrWaitHurt[] =
	{	//三段伤害{每段前摇时长，伤害值}
		//{300ms,2},
		{900ms,m_f伤害},
		//{50ms,5}
	};

	switch (m_类型)
	{
	case 兵:
		if (!m_refEntity.m_spPlayer)
			EntitySystem::Broadcast播放声音(m_refEntity, "TMaFir00");
		break;
	case 近战兵:EntitySystem::Broadcast播放声音(m_refEntity, "Tfrshoot"); break;
	case 工程车:EntitySystem::Broadcast播放声音(m_refEntity, "TSCMin00"); break;
	}

	for (auto wait_hurt : arrWaitHurt)
	{
		if (co_await CoTimer::Wait(std::get<0>(wait_hurt), cancel))//等x秒	前摇
			co_return true;//协程取消

		if (m_refEntity.IsDead())
			co_return false;//自己死亡，不再后摇

		if (wpDefencer.expired())
			break;//要执行后摇

		auto spDefencer = wpDefencer.lock();
		if (spDefencer->IsDead())
			break;//要执行后摇

		if (!m_refEntity.DistanceLessEqual(*spDefencer, 攻击距离(*spDefencer)))
			break;//要执行后摇

		if (!spDefencer->m_spDefence)
			break;//目标打不了

		if (m_refEntity.m_spPlayer && m_类型 == 兵)
			EntitySystem::Broadcast播放声音(m_refEntity, "音效/TTaFir00");

		spDefencer->m_spDefence->受伤(std::get<1>(wait_hurt));//第n次让对方伤
	}

	if (co_await CoTimer::Wait(800ms, cancel))//后摇
		co_return true;//协程取消

	if (!m_refEntity.IsDead())
	{
		EntitySystem::BroadcastChangeSkeleAnimIdle(m_refEntity);//播放休闲待机动作
	}

	co_return false;//协程正常退出
}