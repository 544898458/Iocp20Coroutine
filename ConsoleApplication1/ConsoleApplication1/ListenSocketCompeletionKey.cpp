#include "ListenSocketCompeletionKey.h"

void ListenSocketCompeletionKey::StartCoRoutine() 
{
	//auto op = new OpAccept();
	auto pAcceptOverlapped = new MyOverlapped();
	pAcceptOverlapped->coTask = PostAccept(pAcceptOverlapped) ;
	pAcceptOverlapped->coTask.Run();
}
void ListenSocketCompeletionKey::AcceptEx(MyOverlapped* pAcceptOverlapped)
{
	char str2[1];// = new char[1024];// = { 0 };
	DWORD dwRecvcount = 0;
	//int b = WSAGetLastError();
	//OVERLAPPED* Overlapped = new OVERLAPPED();
	BOOL bRes = ::AcceptEx(
		this->Socket(),	//[in]侦听套接字。服务器应用程序在这个套接字上等待连接。
		pAcceptOverlapped->socket,	//[in]将用于连接的套接字。此套接字必须不能已经绑定或者已经连接。
		str2, //[in]指向一个缓冲区，该缓冲区用于接收新建连接的所发送数据的第一个块、该服务器的本地地址和客户端的远程地址。接收到的数据将被写入到缓冲区0偏移处，而地址随后写入。 该参数必须指定，如果此参数设置为NULL，将不会得到执行，也无法通过GetAcceptExSockaddrs函数获得本地或远程的地址。
		0,	//[in]lpOutputBuffer字节数，指定接收数据缓冲区lpOutputBuffer的大小。这一大小应不包括服务器的本地地址的大小或客户端的远程地址，他们被追加到输出缓冲区。如果dwReceiveDataLength是零，AcceptEx将不等待接收任何数据，而是尽快建立连接。
		sizeof(struct sockaddr_in) + 16,//[in]为本地地址信息保留的字节数。此值必须比所用传输协议的最大地址大小长16个字节。
		sizeof(struct sockaddr_in) + 16,//[in]为远程地址的信息保留的字节数。此值必须比所用传输协议的最大地址大小长16个字节。 该值不能为0。
		&dwRecvcount,//[out]指向一个DWORD用于标识接收到的字节数。此参数只有在同步模式下有意义。如果函数返回ERROR_IO_PENDING并在迟些时候完成操作，那么这个DWORD没有意义，这时你必须获得从完成通知机制中读取操作字节数。
		&pAcceptOverlapped->overlapped//overlapped这里面内存必须清零，否则WSAGetLastError会返回ERROR_INVALID_HANDLE
	);
	const auto lastErr = WSAGetLastError();
	if (bRes && 0 == lastErr)//同步返回
	{
		AcceptEx(pAcceptOverlapped);
	}
	if (!bRes && lastErr != ERROR_IO_PENDING)
	{
		switch (lastErr)
		{
		default:
			printf("AcceptEx err=%d", lastErr);
			break;
		}
		
	}
}
CoTask<MyOverlapped*> ListenSocketCompeletionKey::PostAccept(MyOverlapped* pAcceptOverlapped)
{
	//auto pAcceptOverlapped = new MyOverlapped(new OpAccept());
	
	while (true) {
		pAcceptOverlapped->socket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
		//all_olp[count].hEvent = WSACreateEvent();
		AcceptEx(pAcceptOverlapped);
		co_yield pAcceptOverlapped;
		if (!pAcceptOverlapped->bGetQueuedCompletionStatusReturn)
		{
			switch (pAcceptOverlapped->lastErr)
			{
			case ERROR_OPERATION_ABORTED:
				printf("The I/O operation has been aborted because of either a thread exit or an application request.");
				break;
			default:
				break;
			}
		}
		printf("重叠Accept完成：accept\n");
		//绑定到完成端口
		auto pNewCompleteKey = new SessionSocketCompeletionKey(pAcceptOverlapped->socket);
		//pNewCompleteKey->socket = ;
		HANDLE hPort1 = CreateIoCompletionPort((HANDLE)pAcceptOverlapped->socket, this->hIocp, (ULONG_PTR)pNewCompleteKey, 0);
		if (hPort1 != this->hIocp)
		{
			int a = GetLastError();
			printf("连上来的Socket关联到完成端口失败，Error=%d\n", a);
			//closesocket(pKey->socket);// all_socks[count]);
			delete pNewCompleteKey;
			co_return 0;
		}
		pNewCompleteKey->StartCoRoutine();
	}
}
