#pragma once
#include"Op.h"
/// <summary>
/// 重叠操作，对应一次Accet、Recv、Send
/// CONTAINING_RECORD（）可以根据Overlapped获取PER_IO_CONTEXT数据类型。前提是Overlapped是PER_IO_CONTEXT的第一个成员。CONTAINING_RECORD可以根据Overlapped的地址获取其所在PER_IO_CONTEXT结构体的地址指针。
///	PER_IO_CONTEXT* pIoContext = CONTAINING_RECORD(lpOverlapped, PER_IO_CONTEXT, m_Overlapped);
/// </summary>
struct MyOverlapped
{
	//enum Op
	//{
	//	Accept,
	//	Recv,
	//	Send,
	//};

	OVERLAPPED overlapped = { 0 };

	
	SOCKET socket=NULL;

	//完成端口返回结果，GetQueuedCompletionStatus 返回结果
	DWORD number_of_bytes;
	BOOL bGetQueuedCompletionStatusReturn;
	int lastErr;

	void OnComplete(SocketCompeletionKey* pKey, const HANDLE port, const DWORD number_of_bytes, const BOOL bGetQueuedCompletionStatusReturn, const int lastErr)
	{
		this->number_of_bytes = number_of_bytes;
		this->bGetQueuedCompletionStatusReturn = bGetQueuedCompletionStatusReturn;
		this->lastErr = lastErr;
		this->coTask.Run();
		//pOp->OnComplete(this, pKey, port,number_of_bytes,bGetQueuedCompletionStatusReturn,lastErr);
	}
	CoTask<MyOverlapped*> coTask;
};
